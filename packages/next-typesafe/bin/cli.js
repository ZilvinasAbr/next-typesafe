#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

function extractDynamicParams(routePath) {
  const segments = routePath.split('/');
  const params = [];
  
  for (const segment of segments) {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      const paramName = segment.slice(1, -1);
      if (paramName.startsWith('...')) {
        // Catch-all route
        params.push({ name: paramName.slice(3), type: 'string[]' });
      } else {
        // Dynamic route
        params.push({ name: paramName, type: 'string' });
      }
    }
  }
  
  return params;
}

function generatePageType(routePath, params) {
  const hasParams = params.length > 0;
  
  let typeContent = '// This file is auto-generated. Do not edit this file directly.\n\n';
  
  if (hasParams) {
    const paramsInterface = params
      .map(param => `  ${param.name}: ${param.type};`)
      .join('\n');
    
    typeContent += `export interface PageParams {
${paramsInterface}
}

export interface PageType {
  params: PageParams;
}
`;
  } else {
    typeContent += `export type PageType = Record<string, never>;
`;
  }
  
  return typeContent;
}

function findPageFiles(dir, files = []) {
  if (!fs.existsSync(dir)) {
    return files;
  }
  
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    
    if (entry.isDirectory()) {
      findPageFiles(fullPath, files);
    } else if (entry.name === 'page.tsx') {
      files.push(fullPath);
    }
  }
  
  return files;
}

function findAppDirectory() {
  // Look for common Next.js app directory patterns
  const possiblePaths = [
    'app',
    'src/app'
  ];
  
  for (const appPath of possiblePaths) {
    if (fs.existsSync(appPath) && fs.lstatSync(appPath).isDirectory()) {
      return appPath;
    }
  }
  
  console.error('Error: Could not find Next.js app directory. Make sure you\'re running this command from the root of a Next.js project with an "app" or "src/app" directory.');
  process.exit(1);
}

async function generatePageTypes() {
  try {
    const command = process.argv[2];
    
    if (command !== 'generate-types') {
      console.log('Usage: next-typesafe generate-types');
      process.exit(1);
    }
    
    // Find the app directory from current working directory
    const appDir = findAppDirectory();
    
    // Find all page.tsx files
    const pageFiles = findPageFiles(appDir);
    
    if (pageFiles.length === 0) {
      console.log('No page.tsx files found in the app directory.');
      return;
    }
    
    console.log(`Found ${pageFiles.length} page.tsx files:`);
    
    for (const pageFile of pageFiles) {
      console.log(`Processing: ${pageFile}`);
      
      // Extract the route path from the file path
      const relativePath = pageFile.replace(appDir, '');
      const routePath = path.dirname(relativePath);
      
      // Extract dynamic parameters from the route
      const params = extractDynamicParams(routePath);
      
      // Generate the type content
      const typeContent = generatePageType(routePath, params);
      
      // Write the _page-type.ts file in the same directory
      const pageDir = path.dirname(pageFile);
      const typeFilePath = path.join(pageDir, '_page-type.ts');
      
      fs.writeFileSync(typeFilePath, typeContent);
      console.log(`Generated: ${typeFilePath}`);
      
      if (params.length > 0) {
        console.log(`  - Parameters: ${params.map(p => `${p.name} (${p.type})`).join(', ')}`);
      } else {
        console.log(`  - No dynamic parameters`);
      }
    }
    
    console.log('\nâœ… Page type generation completed!');
  } catch (error) {
    console.error('Error generating page types:', error);
    process.exit(1);
  }
}

generatePageTypes();